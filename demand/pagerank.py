"""传入某点的经纬度和时间段pagerank 得到预测的信任指数，指数越高，热度越大输出某点的热度预测值"""import osimport pandas as pdimport numpy as npimport matplotlib.pyplot as pltimport ioimport plotly.plotly as pyimport plotly.graph_objs as gofrom matplotlib.path import Pathimport networkx as nxfrom pygeohash import encode,decodeimport DBSCAN_taxi# 预测算法实现，以热点为节点。# 输入的数据格式如下:[23.138249, 113.283787], '2017-02-01 19:53:47'def pagerank_lead(site, time):    # 获取热点    # total_result = DBSCAN_taxi.DBSCAN_qgtaxi(site, time)    # 导入有向图    total_result = [{'longitude': 113.270931176647, 'latitude': 23.115292520367898, 'heat': 5},                    {'longitude': 113.274931676647, 'latitude': 23.115295520467898, 'heat': 3},                    {'longitude': 113.270331676647, 'latitude': 23.115295320367898, 'heat': 6},                    {'longitude': 113.272931676647, 'latitude': 23.115595520367898, 'heat': 4},                    {'longitude': 113.273931676647, 'latitude': 23.114295520367898, 'heat': 8}]    G, geo = get_paint(total_result)    P_n = pageRank(G)    result = {}    for k,v in geo.items():        result[v[0]] = P_n[k]    print(result)    return result# 画出有向图def get_paint(total_result):    sum = 0    geo = {}    # 热点关联条件    for i in range(len(total_result)):        sum += total_result[i]['heat']        geo[i] = []        geo[i].append(encode(total_result[i]['latitude'],total_result[i]['longitude']))        geo[i].append(total_result[i]['heat'])    aver = float(sum)/len(total_result)    print(geo)    G = nx.DiGraph()    for i in range(len(geo)):        for j in range(len(geo)):            if i == j:                continue            if (geo[i][1] + geo[j][1] ) / 2 >= 5:                if geo[i][1]  > geo[j][1]:                    G.add_edge(i, j, weight=geo[i][1]+geo[j][1])                else:                    G.add_edge(j, i, weight=geo[i][1]+geo[j][1])    nx.draw(G, with_labels=True)    # plt.savefig("graph.png")    # plt.show()    # input()    #print(G.edges)    #input()    return G, geodef pageRank(G):    # 记录图中节点个数    N = G.number_of_nodes()    # 生成初步的S矩阵,有关系的边为1，无关系的边为0    S = np.zeros([N, N])    for edge in G.edges:        S[edge[1], edge[0]] = 1    print("初始化1：", S)    # 计算比例,即进行列的归一化处理.每一列各个特征的比例1/N    for j in range(N):        sum_of_col = sum(S[:, j])        for i in range(N):            if sum_of_col == 0:                S[i,j] == 0            else:                S[i, j] /= sum_of_col    print("完全初始化：", S)    # 得到各个热点的pagerank指数    # 计算矩阵A    alpha = 0.85    A = alpha * S + (1 - alpha) / N * np.ones([N, N])    print("矩阵A为：",A)    # 生成初始的PageRank值，记录在P_n中，P_n和P_n1均用于迭代    P_n = np.ones(N) / N            #一开始初始化都一样    P_n1 = np.zeros(N)    e = 100000  # 误差初始化    k = 0  # 记录迭代次数        # 记录迭代停止条件（误差小于0.00000001）    while e > 0.00001:  # 开始迭代        P_n1 = np.dot(A, P_n)  # 迭代公式        e = P_n1 - P_n        e = max(map(abs, e))  # 计算误差        P_n = P_n1        k += 1        print('iteration %s:' % str(k), P_n1)    print('final result:', P_n)         # 输出最终结果N行1列    # 最终返回每个热点的热度情况    return P_npagerank_lead([23.138249, 113.283787], '2017-02-01 19:53:47')