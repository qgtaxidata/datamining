"""传入某点的经纬度和时间段pagerank 得到预测的信任指数，指数越高，热度越大输出某点的热度预测值"""import osimport pandas as pdimport numpy as npimport matplotlib.pyplot as pltimport iofrom matplotlib.path import Pathimport networkx as nxfrom pygeohash import encode,decodeimport DBSCAN_taxi_for_demandimport mathimport randomfrom datetime import datetime, timedelta# 各个区的五级编码信息def Admini_district_geo():    Admini_district_geo_dict = {}    geo_ = [        ["ws0kz", "ws0m6", "ws0my", "ws0t9", "ws0tg", "ws0mw", "ws0sc", "ws0kt", "ws0sf", "ws0te", "ws0mk",         "ws0ts", "ws0m5", "ws0mp", "ws0mm", "ws0w4", "ws0m4", "ws0kq", "ws0t1", "ws0m7", "ws0t2", "ws0mt", "ws0w1",         "ws0tf", "ws0tv", "ws0mq", "ws0t3", "ws0tt", "ws0mj", "ws0tc", "ws0kg", "ws0mr", "ws0w3", "ws0mz",         "ws0mv", "ws0sb", "ws0km", "ws0t8", "ws0ku", "ws0tb", "ws0td", "ws0w6", "ws0mx", "ws0t6", "ws0kw",         "ws0mh", "ws0kf", "ws0t4", "ws0kv", "ws0tu", "ws0t0", "ws0ky", "ws0mn"],        ["ws0c8", "ws0b2", "ws0c0", "ws0c1", "ws09q", "ws09e", "ws0cb", "ws08z", "ws0b6", "ws0c7", "ws0d5", "ws0c5",         "ws0c6", "ws0b9", "ws0bf", "ws0b3", "ws0c3", "ws0dj", "ws09y", "ws09z", "ws09p", "ws0dh", "ws09w", "ws0b8",         "ws09n", "ws0dm", "ws0bd", "ws09x", "ws0c4", "ws09u", "ws0bc", "ws0bb", "ws0c9", "ws09t", "ws0b7", "ws0d7",         "ws08y", "ws0cc", "ws09g", "ws0dk", "ws09s", "ws09v", "ws0be", "ws09r", "ws0c2", "ws0bg"],        ["ws0vs", "ws0ut", "ws0vw", "ws0v0", "ws0vy", "ws0ur", "ws0ym", "ws0gg",         "ws0gy", "ws1h3", "ws1jb", "ws1hf", "ws0vr", "ws0v5", "ws0gb", "ws0yh",         "ws0uk", "ws0vh", "ws1j3", "ws0uh", "ws0ud", "ws0uq", "ws0vv", "ws0vk", "ws0us",         "ws0yq", "ws1j2", "ws0vx", "ws1h8", "ws0g9", "ws0v2", "ws0g8", "ws0u9", "ws0u5", "ws0uz", "ws0vz",         "ws0v4", "ws0uj", "ws0u3", "ws0v6",         "ws0uy", "ws0vu", "ws0un", "ws1j4", "ws0yn", "ws1hc", "ws0v3", "ws0ux", "ws0u1", "ws0uv", "ws0g3",         "ws1h9", "ws0vt", "ws1h6", "ws1j6",         "ws1j8", "ws0u6", "ws0g2", "ws1hd", "ws0u8", "ws0ug", "ws0u4", "ws0vm", "ws0v1", "ws1h2", "ws0gf",         "ws0gu", "ws0gv", "ws0vq", "ws0uw",         "ws0uc", "ws1j1", "ws0vj", "ws0yk", "ws0vp", "ws0gc", "ws0vn", "ws0uu", "ws1hb", "ws0u7", "ws0v7",         "ws0u2", "ws0yj", "ws1j0", "ws0ub", "ws0ue", "ws0u0", "ws0um", "ws0uf"],        ["ws1pc", "ws0ws", "ws0zp", "ws0z6", "ws0yu", "ws0wt", "ws1p0", "ws0zd", "ws0y7", "ws1pd", "ws300",         "ws0y4", "ws1p1", "ws0yv", "ws0zn", "ws0vd", "ws0zm", "ws1nb", "ws0wm", "ws0vf", "ws0y1", "ws0zu",         "ws0wk", "ws0y5", "ws0yw", "ws304", "ws1p3", "ws1p8", "ws0vc", "ws0yt", "ws0we", "ws0y3", "ws301",         "ws0y0", "ws1pb", "ws0w5", "ws1pf", "ws0wv", "ws0zt", "ws0ze", "ws0zy", "ws0v8", "ws0ty", "ws0zq",         "ws0ys", "ws2bj", "ws0wn", "ws0yf", "ws2bp", "ws0v9", "ws1p4", "ws0z5", "ws1p9", "ws2bh", "ws0zx",         "ws0wu", "ws0yy", "ws0vb", "ws0z7", "ws0y6", "ws0zs", "ws0tw", "ws0yz", "ws0yg", "ws0wp", "ws0zj",         "ws0zz", "ws0wj", "ws0zw", "ws0zh", "ws0vg", "ws1p6", "ws0yx", "ws1n8", "ws0wh", "ws0yd", "ws0tz",         "ws0wq", "ws1p2", "ws0zr", "ws0tx", "ws0y2", "ws0zv", "ws0ye", "ws0zk", "ws0w7", "ws0z4", "ws2bn",         "ws0wg", "ws0wr", "ws0ve"],        ["ws0d1", "ws0d9", "ws0dp", "ws0d6", "ws0dr", "ws0d4", "ws0dd", "ws0dc", "ws0dv", "ws0dn", "ws0d3",         "ws0dx", "ws0dw", "ws0de", "ws0en", "ws0ej", "ws0ds", "ws0dg", "ws0e4", "ws0eh", "ws0dt", "ws0du",         "ws0dq", "ws0e1", "ws0dz", "ws0dy", "ws0df", "ws0e5", "ws0ep"],        ["ws0sm", "ws0kx", "ws0s6", "ws0ef", "ws0s0", "ws0sk", "ws0tj", "ws0t5", "ws0sr", "ws0sd", "ws0s7",         "ws0kp", "ws0sg", "ws0eb", "ws0tm", "ws0se", "ws0s2", "ws0th", "ws0s1", "ws0st", "ws07z", "ws0sx",         "ws0s8", "ws0ec", "ws0ss", "ws0sq", "ws0sw", "ws0su", "ws0tk", "ws0sv", "ws0t7", "ws0s3", "ws0s4",         "ws0s9", "ws0kr"],        ["ws0tp", "ws0ey", "ws0tn", "ws0ex", "ws0tq", "ws0sy", "ws0er", "ws0eq", "ws0ew", "ws0tr", "ws0sp",         "ws0ez", "ws0sn", "ws0sz"],        ["ws0e8", "ws0e2"],        ["ws0ee", "ws0em", "ws0et", "ws0e9", "ws0e7", "ws0ed", "ws0es", "ws0ek", "ws0e6", "ws0e3"],        ["ws0eu", "ws0sh", "ws0s5", "ws0ev", "ws0sj", "ws0eg"],        ["ws07r", "ws07x"]    ]    # input(len(geo_))    # 整个广州的geo编码    # geo_all_gz = []    # for i in geo_ :    #     geo_all_gz.extend(i)    # geo_all_gz = list(set(geo_all_gz))    # geo_.insert(0,geo_all_gz)    for i in range(len(geo_)):        Admini_district_geo_dict[i] = geo_[i]    # input(Admini_district_geo_dict)    return Admini_district_geo_dict# 预测算法实现，以热点为节点。# 输入的数据格式如下:[23.138249, 113.283787], '2017-02-01 19:53:47'def pagerank_lead(total_result,flags):    # 获取热点    # total_result, flags = DBSCAN_taxi_for_demand.DBSCAN_qgtaxi(site, time)    G, geo = get_paint(total_result,flags)    # 得到概率指数    P_n = pageRank(G)    result = {}    for k,v in geo.items():        result[v[0]] = P_n[k]    # print("预测指数字典：",result)    predict_result = []    for i in range(len(result)):        dict_ = {}        dict_['latitude'],dict_['longitude'] = decode(list(result.keys())[i])        # 向上取整        dict_['heat'] = math.ceil(result[list(result.keys())[i]] * total_result[i]['heat'])        predict_result.append(dict_)    # print("最终聚类结果:",'\n',predict_result)    return predict_result# 画出有向图def get_paint(total_result,flags):    geo = {}    G = nx.DiGraph()    if -1 in flags:        # 热点关联条件        for i in range(-1,len(total_result)-1):            # if i == -1:            #     geo[i] = []            #     geo[i].append(encode(total_result[-1]['latitude'], total_result[-1]['longitude']))            #     geo[i].append(total_result[i]['heat'])            # 最后一个为离群点            geo[i] = []            geo[i].append(encode(total_result[i]['latitude'],total_result[i]['longitude']))            geo[i].append(total_result[i]['heat'])        # 输出geo:geo的格式类似这个： {1: ['ws0e98h235qu', 3]}        #print("画图：",geo)        # print("----------------------------------")       # input()        # 离群点的关系:一个点必为-1//////随机节点个数次。        # 迭代次数        for i in range(len(geo)-1):            # 记录两节点            node_t = [-1]            # 随机选择的节点            node = random.randrange(len(geo)-1)            node_t.append(node)           # print("本次选的两个点是：",node_t)            #随机选择一个            a = random.choice(node_t)            node_t.remove(a)            b = node_t [0]            # print("分别是：",a,b)            G.add_edge(a, b, weight=geo[-1][1]/(len(geo)-1))        # print("--------------------------------------")        # 除离群点以外的蔟之间的关系        for i in range(len(geo)-1):            for j in range(len(geo)-1):                if i == j:                    continue                # print("现在是这两个点：",i,j)                # print(pd.DataFrame(geo.values()).iloc[1:,-1].sum()/(len(geo)-1))                if (geo[i][1] + geo[j][1]) / 2 >= (pd.DataFrame(geo.values()).iloc[1:,-1].sum()/(len(geo)-1)):                    # print("11")                    if geo[i][1] > geo[j][1]:                        G.add_edge(i, j, weight=geo[i][1] + geo[j][1])                    else:                        G.add_edge(j, i, weight=geo[i][1] + geo[j][1])        # print(G.edges)    else:        # print("到这里")        for i in range(len(total_result)):            # print(i)            geo[i] = []            # print(total_result)            # input(total_result[i]['latitude'])            geo[i].append(encode(total_result[i]['latitude'],total_result[i]['longitude']))            geo[i].append(total_result[i]['heat'])        # print("画图：", geo)        # print("----------------------------------")        #input(pd.DataFrame(geo.values()).iloc[:,-1].sum())        for i in range(len(geo)):            for j in range(len(geo)):                if i == j:                    continue                if (geo[i][1] + geo[j][1]) / 2 >= (pd.DataFrame(geo.values()).iloc[:,-1].sum()/len(geo)):                    if geo[i][1] > geo[j][1]:                        G.add_edge(i, j, weight=geo[i][1] + geo[j][1])                    else:                        G.add_edge(j, i, weight=geo[i][1] + geo[j][1])    # nx.draw(G, with_labels=True)    # plt.savefig("graph.png")    # plt.show()    # input()    return G, geodef pageRank(G):    # 记录图中节点个数    N = G.number_of_nodes()    if N == 0:        # print("haha")        return [1]    else:        # 生成初步的S矩阵,有关系的边为1，无关系的边为0        S = np.zeros([N, N])        # 权重矩阵        # print(G.edges)        # 离群点是最后一个        for edge in G.edges:            S[edge[1], edge[0]] = G.get_edge_data(edge[0], edge[1])['weight']        # print("初始化1：", S)        # 计算比例,即进行列的归一化处理.每一列各个特征的比例1/N        for j in range(N):            # 求一列的和            sum = math.fsum(S[:,j])            for i in range(N):                if S[i,j] == 0:                    S[i, j] = 0                else:                    S[i, j] = S[i, j]/sum        # print("完全初始化：", S)        # 得到各个热点的pagerank指数，计算矩阵A        alpha = 0.85        A = alpha * S + (1 - alpha) / N * np.ones([N, N])        # print("矩阵A为：",A)        # 生成初始的PageRank值，记录在P_n中，P_n和P_n1均用于迭代        P_n = np.ones(N) / N            # 设初始时每个页面的rank值为1/N        P_n1 = np.zeros(N)        e = 100000  # 误差初始化        k = 0  # 记录迭代次数        # 记录迭代停止条件（误差小于0.00000001）        while e > 0.00000001:  # 开始迭代            P_n1 = np.dot(A, P_n)  # 迭代公式            e = P_n1 - P_n            e = max(map(abs, e))  # 计算误差            P_n = P_n1            k += 1            # print('iteration %s:' % str(k), P_n1)        # print('final result:', P_n)                        # 输出最终结果N行1列        while 1:            flag = 1            for i in P_n:                if i > 10.0:                    flag = 0            if flag == 0:                P_n /= 10                break            P_n *= 10        # print("量化之后:",P_n)    return P_ndef get_date_time(strs):    return datetime.strptime(strs, '%Y-%m-%d %H:%M:%S')def demand(num,time):    """    :param num: 区号    :param time: 时间点    :return: # 返回结果列表，列表中三个函数，分别代表前一段时间热点数，本时间段热点数，预测出来的热带你数目    """    num -= 1    geo_dict_ = Admini_district_geo()    # 存放预测结果    total_predict_result = []    # 记录热点个数    sum_present = 0    sum_early = 0    sum_predict = 0    # 遍历该区各个五级编码    for i in range(len(geo_dict_[num])):        # print(geo_dict_[num][i], time)        dt = get_date_time(time)        # 时间变化(变化的参数可以自己调，但是要与init中选取的时间间隔相等)        # init中是delta = 3600，故这里变化的小时即为1h。        dt = dt - timedelta(hours=1)        # print(geo_dict_[num][i], str(dt))        total_result_early, flags = DBSCAN_taxi_for_demand.DBSCAN_qgtaxi(geo_dict_[num][i], str(dt))        for k in total_result_early:            sum_early += k['heat']        total_result, flags = DBSCAN_taxi_for_demand.DBSCAN_qgtaxi(geo_dict_[num][i], time)        #现阶段实时热点        for j in total_result:            sum_present += j['heat']        # 记录预测热点结果        for n in pagerank_lead(total_result,flags):            sum_predict  += n['heat']        # total_predict_result.extend(pagerank_lead(total_result,flags))    result = []    # 记录当前数据的热点数目    result.append(sum_early)    # 记录前一小时的热点数目    result.append(sum_present)    #记录预测出来的热点数目    result.append(sum_predict)    print(result)    return result# 第n个区if __name__ == "__main__":    demands = demand(10, '2017-02-03 19:15:48')    dic = dict()    dic['his'] = demands[0]    dic['now'] = demands[1]    dic['fut'] = demands[2]    print(dic)