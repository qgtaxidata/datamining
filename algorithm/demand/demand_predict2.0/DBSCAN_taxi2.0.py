"""作者：树蛙4号时间：2019.08.08实验：调用python中sklearn库实现密度聚类算法# 密度：空间中任意一点的密度是以该点为圆心，以EPS为半径的圆区域内包含的点数目# 边界点：空间中某一点的密度，如果小于某一点给定的阈值minpts,则称为边界点# 噪声点：不属于核心点，也不属于边界点的点，也就是密度为1的点# API:    # model = sklearn.cluster.DBSCAN(eps_领域大小圆半径,min_samples_领域内，点的个数的阈值)    # model.fit(data) 训练模型    # model.fit_predict(data) 模型的预测方法调库需要传入两个参数，矩阵型数据/数组类型，返回列表最后预测出来需求量""""""-------载客热点推荐-------1、接受客户的地点经纬度和时间；2、将客户的地点经纬度转化成全球坐标以及geohash编码；3、数据库接口：找出相同geohash、相同时间中的所有订单，获取经纬度（记得经纬度类型转化）；4、对所有经纬度进行密度聚类，返回字典，一类有多少个点  以及  一类中随机一个单子"""from pygeohash import encode,decodeimport pandas as pdimport numpy as npfrom sklearn.cluster import DBSCANimport warningsfrom db_tools import *from coordinate import wgs_gcjwarnings.filterwarnings('ignore')# 转化坐标,返回编码def transfer(lat, lon):    geohash_ = encode(lon, lat)    return geohash_def find_mysql(geo, time):    # geohash_ = transfer(lat, lon)    all_points = query_operate_pos(time, geo)    #input()    # print(all_points)    # input()    # print("aa",all_points)    return all_points    # 根据geohash、time 找到对应的单子，返回二维列表def DBSCAN_achieve(eps, MinPts, data):    data = pd.DataFrame(data)    model = DBSCAN(eps, MinPts)    if len(data) == 0:        return []    # print(data)    model.fit(data)    # input(data.iloc[:, :-1])    data['result'] = model.fit_predict(data)    # 存放总结果    total_result = []    flags = []    for flag in list(set(data['result'].as_matrix().tolist())):        flags.append(flag)        # 存放每一类结果        result = []        # 记录每一类的个数        Dict_count = {}        result.append(np.array(data[data['result']== flag]).tolist()[0])        gcj_point = wgs_gcj(list(map(float, result[0]))[0],list(map(float, result[0]))[1])        Dict_count['longitude'] = gcj_point[0]        Dict_count['latitude'] = gcj_point[1]        Dict_count['heat'] = len(data[data['result']== flag])        total_result.append(Dict_count)    # print("loook here111:",total_result,flags)    return total_result,flagsdef discrete_points(points):    flags = []    for i in range(len(points)):        flags.append(i)        points[i] = list(map(float, points[i]))    result = list()    for point in points:        hot_spot = dict()        gcj_point = wgs_gcj(point[0],point[1])        hot_spot['longitude'] = gcj_point[0]        hot_spot['latitude'] = gcj_point[1]        hot_spot['heat'] = 1        result.append(hot_spot)    # print('total_result : %s' % str(result))    # print(flags)    # print("--------------------------------------")    return result,flagsdef DBSCAN_qgtaxi(geo, time):    """point 的类型是[lat, lon]"""    data = find_mysql(geo, time)    # print("zhaochuai",data)    # print("jajja",data)    # (data)    point0,point1 = decode(geo)    point = [point0,point1]    # 没有数据时，数据热点为0，    if len(data) == 0:        return [{'longitude':point[1],'latitude':point[0],'heat':0}] ,[0]    # 数据点小于十二个点就自成一类    if len(data) < 12:        return discrete_points(data)    iter_num = 0    eps = 0.0001    MinPts = 5    # print("选出来的数据为：",data)    # print("------------------------------")    total_result,flags = DBSCAN_achieve(eps, MinPts, data)    # 最多迭代30次    while iter_num < 30:        # print("让我看看这次聚类有多少类：",len(total_result))        # 聚类减少        if len(total_result) >= 12:            eps += 0.00002        # 聚类增多        elif len(total_result) < 3:            # print("有运行到这里吗？")            eps -= 0.00002            # print("看看这时候的半径：", eps)        else:            break        if eps < 0:            break        iter_num += 1        # print("正在进行第%d次聚类" % iter_num)        try_result,flags = DBSCAN_achieve(eps, MinPts, data)        # print("ha",try_result,flags)        if len(try_result) > 0:            total_result = try_result    # print('total_result : %s' % str(total_result))    # print(flags)    # print("--------------------------------------")    return total_result,flagsif __name__ == '__main__':    #total_result = DBSCAN_qgtaxi([23.117976,113.265602], '2017-02-02 00:15:48')    geo = 'ws0e9'    dt = '2017-02-01 23:15:48'    total_result_early, flags = DBSCAN_qgtaxi(geo, dt)    #print(total_result)