from db_tools import *from datetime import datetime, timedeltaimport matplotlib.pyplot as pltfrom statsmodels.tsa.arima_model import ARIMAimport numpy as npimport pandas as pdfrom statsmodels.tsa.seasonal import  seasonal_decomposeimport warningswarnings.filterwarnings('ignore')# def Region():#     Adamin_Region = {#         1: ["ws0kz","ws0m6","ws0my","ws0t9","ws0tg","ws0mw","ws0sc","ws0kt","ws0sf","ws0te","ws0mk","ws0ts","ws0m5","ws0mp","ws0mm","ws0w4","ws0m4","ws0kq","ws0t1","ws0m7","ws0t2","ws0mt","ws0w1","ws0tf","ws0tv","ws0mq","ws0t3","ws0tt","ws0mj","ws0tc","ws0kg","ws0mr","ws0w3","ws0mz","ws0mv","ws0sb","ws0km","ws0t8","ws0ku","ws0tb","ws0td","ws0w6","ws0mx","ws0t6","ws0kw","ws0mh","ws0kf","ws0t4","ws0kv","ws0tu","ws0t0","ws0ky","ws0mn"],#         2: ["ws0c8","ws0b2","ws0c0","ws0c1","ws09q","ws09e","ws0cb","ws08z","ws0b6","ws0c7","ws0d5","ws0c5","ws0c6","ws0b9","ws0bf","ws0b3", "ws0c3","ws0dj","ws09y","ws09z","ws09p","ws0dh","ws09w","ws0b8","ws09n","ws0dm","ws0bd","ws09x", "ws0c4","ws09u","ws0bc","ws0bb","ws0c9","ws09t","ws0b7","ws0d7","ws08y","ws0cc","ws09g","ws0dk","ws09s","ws09v","ws0be","ws09r","ws0c2","ws0bg"],#         3: ["ws0vs", "ws0ut", "ws0vw", "ws0v0", "ws0vy", "ws0ur", "ws0ym", "ws0gg", "ws0gy", "ws1h3", "ws1jb", "ws1hf", "ws0vr", "ws0v5", "ws0gb", "ws0yh", "ws0uk", "ws0vh", "ws1j3", "ws0uh", "ws0ud", "ws0uq", "ws0vv", "ws0vk", "ws0us", "ws0yq", "ws1j2", "ws0vx", "ws1h8", "ws0g9", "ws0v2", "ws0g8", "ws0u9", "ws0u5", "ws0uz", "ws0vz", "ws0v4", "ws0uj", "ws0u3", "ws0v6", "ws0uy", "ws0vu", "ws0un", "ws1j4", "ws0yn", "ws1hc", "ws0v3", "ws0ux", "ws0u1", "ws0uv", "ws0g3", "ws1h9", "ws0vt", "ws1h6", "ws1j6", "ws1j8", "ws0u6", "ws0g2", "ws1hd", "ws0u8", "ws0ug", "ws0u4", "ws0vm", "ws0v1", "ws1h2", "ws0gf", "ws0gu", "ws0gv", "ws0vq", "ws0uw", "ws0uc", "ws1j1", "ws0vj", "ws0yk", "ws0vp", "ws0gc", "ws0vn", "ws0uu", "ws1hb", "ws0u7", "ws0v7", "ws0u2", "ws0yj", "ws1j0", "ws0ub", "ws0ue", "ws0u0", "ws0um", "ws0uf"],#         4: ["ws1pc", "ws0ws", "ws0zp", "ws0z6", "ws0yu", "ws0wt", "ws1p0", "ws0zd", "ws0y7", "ws1pd", "ws300", "ws0y4", "ws1p1", "ws0yv", "ws0zn", "ws0vd", "ws0zm", "ws1nb", "ws0wm", "ws0vf", "ws0y1", "ws0zu", "ws0wk", "ws0y5", "ws0yw", "ws304", "ws1p3", "ws1p8", "ws0vc", "ws0yt", "ws0we", "ws0y3", "ws301", "ws0y0", "ws1pb", "ws0w5", "ws1pf", "ws0wv", "ws0zt", "ws0ze", "ws0zy", "ws0v8", "ws0ty", "ws0zq", "ws0ys", "ws2bj", "ws0wn", "ws0yf", "ws2bp", "ws0v9", "ws1p4", "ws0z5", "ws1p9", "ws2bh", "ws0zx", "ws0wu", "ws0yy", "ws0vb", "ws0z7", "ws0y6", "ws0zs", "ws0tw", "ws0yz", "ws0yg", "ws0wp", "ws0zj", "ws0zz", "ws0wj", "ws0zw", "ws0zh", "ws0vg", "ws1p6", "ws0yx", "ws1n8", "ws0wh", "ws0yd", "ws0tz", "ws0wq", "ws1p2", "ws0zr", "ws0tx", "ws0y2", "ws0zv", "ws0ye", "ws0zk", "ws0w7", "ws0z4", "ws2bn", "ws0wg", "ws0wr", "ws0ve"],#         5: ["ws0d1", "ws0d9", "ws0dp", "ws0d6", "ws0dr", "ws0d4", "ws0dd", "ws0dc", "ws0dv", "ws0dn", "ws0d3", "ws0dx", "ws0dw", "ws0de", "ws0en", "ws0ej", "ws0ds", "ws0dg", "ws0e4", "ws0eh", "ws0dt", "ws0du", "ws0dq", "ws0e1", "ws0dz", "ws0dy", "ws0df", "ws0e5", "ws0ep"],#         6: ["ws0sm", "ws0kx", "ws0s6", "ws0ef", "ws0s0", "ws0sk", "ws0tj", "ws0t5", "ws0sr", "ws0sd", "ws0s7", "ws0kp", "ws0sg", "ws0eb", "ws0tm", "ws0se", "ws0s2", "ws0th", "ws0s1", "ws0st", "ws07z", "ws0sx", "ws0s8", "ws0ec", "ws0ss", "ws0sq", "ws0sw", "ws0su", "ws0tk", "ws0sv", "ws0t7", "ws0s3", "ws0s4", "ws0s9", "ws0kr"],#         7: ["ws0tp", "ws0ey", "ws0tn", "ws0ex", "ws0tq", "ws0sy", "ws0er", "ws0eq", "ws0ew", "ws0tr", "ws0sp", "ws0ez", "ws0sn", "ws0sz"],#         8: ["ws0e8","ws0e2"],#         9: ["ws0ee", "ws0em", "ws0et", "ws0e9", "ws0e7", "ws0ed", "ws0es", "ws0ek", "ws0e6", "ws0e3"],#         10: ["ws0eu", "ws0sh", "ws0s5", "ws0ev", "ws0sj", "ws0eg"],#         11: ["ws07r","ws07x"]#     }#     return Adamin_Regiondef loadData(rate_dict):    dataSet = get_traindata(rate_dict)  # 传入参数    paint_dataSet = []    # print(dataSet)    i = 0    for data in dataSet:        # print(data)        time_ = data[1]        now_time = (get_date_time(time_[0]) + timedelta(hours=0.5))        paint_dataSet.append([i, data[0],str(now_time)])        i += 1    dataSet = pd.DataFrame(paint_dataSet, columns=['count','income', 'date'])    # print("经整理：",dataSet)    return dataSetdef get_date_time(strs):    return datetime.strptime(strs, '%Y-%m-%d %H:%M:%S')def time_experate(date_time, hours, day):    """    区间选择器，这个hours表示将每天分成几个小时，day是表示一共前面历史天数    :param date_time:    :param hours:    :param day:    :return:返回所有遍历的时间区间    """    date_time = get_date_time(date_time) + timedelta(days=1)    pre_date_time = date_time - timedelta(days=day)    if pre_date_time < get_date_time('2017-02-01 00:00:00'):        pre_date_time = get_date_time('2017-02-01 00:00:00')        day = date_time - pre_date_time        day = int(str(day)[0])    num = int(24 / hours)    time_stamp = []    # input(day)    for j in range(day):        for i in range(num):            date_time1 = pre_date_time + timedelta(hours=hours) * (i + 1)            date_time2 = pre_date_time + timedelta(hours=hours) * i            # 时间区间            time_stamp.append([str(date_time2), str(date_time1)])        pre_date_time = pre_date_time + timedelta(days=1)    # print(time_stamp)    return time_stampdef get_traindata(rate_dict, hours=1, day=7):    area = rate_dict['area']    date = rate_dict['date']    date = get_date_time(date) + timedelta(days=2)    # 代表某一天    date_time = str(date)[:11] + "00:00:00"    time_stamp = time_experate(date_time, hours, day)    train_data = []    # all_geohashs = Adamin_Region[area]    for time_ in time_stamp:        date = time_[0]        a = get_info_of_income(area, date)        if a == []:            train_data.append([0.0,time_])            # print(train_data)        else:            train_data.append(get_info_of_income(area, date))    return train_dataclass ModeDecomp(object):    def __init__(self, dataSet, test_size = 24):        data = dataSet.set_index('date')        data.index = pd.to_datetime(data.index)        self.dataSet = data        self.test_size = test_size        self.train_size = len(self.dataSet) - self.test_size        self.income_train = self.dataSet['income'][:len(self.dataSet) - test_size]        # 差分        # print(self.income_train)        self.train = self._diff_smooth(self.income_train)        # 预测数据        self.test =  self.dataSet['income'][-test_size:]        print("测试集：",self.test)        print("训练集：",self.train)    def paint_draw(self):        smooth_income = np.array(self.income_train).tolist()        x = range(len(smooth_income))        plt.plot(x, smooth_income, 'r-')        plt.show()    # 对数据进行平滑处理    def _diff_smooth(self, dataSet):        dif = dataSet.diff(1)         # 差分序列        td = dif.describe()        high = td['75%'] + 1.5 * (td['75%'] - td['25%'])  # 定义高点阈值，1.5倍四分位距之外        low = td['25%'] - 1.5 * (td['75%'] - td['25%'])  # 定义低点阈值，同上        # 变化幅度超过阈值的点的索引        forbid_index = dif[(dif > high) | (dif < low)].index        i = 0       # print("异常点索引：",forbid_index)        while i < len(forbid_index) - 1:            n = 1  # 发现连续多少个点变化幅度过大，大部分只有单个点            start = forbid_index[i]  # 异常点的起始索引            # while ((i+n) <= len(forbid_index) - 1) & (forbid_index[i + n] == start + timedelta(minutes=60 * n)):            while forbid_index[i + n] == start + timedelta(minutes=60 * n):                n += 1                if ( i + n ) > len(forbid_index) - 1:                    break            i += n - 1            end = forbid_index[i]  # 异常点的结束索引           # print("关于异常点：",start,end)            # 用前后值的中间值均匀填充            value = np.linspace(dataSet[start - timedelta(minutes=60)], dataSet[end + timedelta(minutes=60)], n)            dataSet[start: end] = value            i += 1        return dataSet    # 分解(decomposing) 可以用来把时序数据中的趋势和周期性数据都分离出来:    def decomp(self, freq):        decomposition = seasonal_decompose(self.train, freq=freq, two_sided=False)        #  trend（趋势部分）        self.trend = decomposition.trend        # seasonal（季节性部分）        self.seasonal = decomposition.seasonal        #  residual(残留部分)        self.residual = decomposition.resid        # print(self.trend,self.seasonal)        # decomposition.plot()        # plt.show()        # 生成描述性统计        d = self.residual.describe()        # print(d)        delta = d['75%'] - d['25%']        self.low_error, self.high_error = (d['25%'] - 1*delta, d['75%'] + 1*delta)    def trend_model(self, order):        self.trend.dropna(inplace=True)        self.trend_model = ARIMA(self.trend, order).fit(disp=-1, method='css')        return self.trend_model    def predict_new(self):        """        预测新数据        :return:        """        n = self.test_size        self.pred_time_index = pd.date_range(start=self.train.index[-1], periods = n+1, freq='60min')[1:]        self.trend_pred = self.trend_model.forecast(n)[0]        # print("最初预测结果：",self.trend_pred)        pred_time_index = self.add_season()        return pred_time_index    def add_season(self):        '''        为预测出的趋势数据添加周期数据和残差数据        '''        self.train_season = self.seasonal[:self.train_size]        # input(self.train_season )        values = []        low_conf_values = []        high_conf_values = []        for i,t in enumerate(self.pred_time_index):            trend_part = self.trend_pred[i]            #相同时间的数据均值            season_part = self.train_season[self.train_season.index.time == t.time()].mean()            #趋势+周期+误差界限            predict = trend_part + season_part            low_bound = trend_part + season_part + self.low_error            high_bound = trend_part + season_part + self.high_error            values.append(predict)            low_conf_values.append(low_bound)            high_conf_values.append(high_bound)        self.final_pred = pd.Series(values, index=self.pred_time_index, name='predict')        self.low_conf = pd.Series(low_conf_values, index=self.pred_time_index, name='low_conf')        self.high_conf = pd.Series(high_conf_values, index=self.pred_time_index, name='high_conf')        return self.pred_time_indexdef get_MAPE(pre_result):    error_rate = 0.0    for one in pre_result:        if one[2] == 0:            pass        else:            error_rate += abs((one[2] - one[1]) / one[2])    # print(error_rate)    # print("误差为：" , (error_rate/len(pre_result)))def main_ARIMR(date,area):    date = date + ' ' + '08:32:48'    rate_dict = {}    rate_dict['date'] = date    rate_dict['area'] = area    data = loadData(rate_dict)           #可调用getdata函数    print(data)    name = ['花都区', '南沙区', '增城区', '从化区', '番禺区', '白云区', '黄埔区', '荔湾区', '海珠区', '天河区', '越秀区']    mode = ModeDecomp(data, test_size=48)       #调节test_size可获取多天预测结果    mode.decomp(48)    mode.trend_model(order=(1, 1, 3))    pred_time_index = mode.predict_new()    pred = mode.final_pred    test = mode.test    pred1 = np.array(pred).tolist()    test1 = np.array(test).tolist()    result = {}    result['title'] = name[area - 1] + '区域收入预测'    # input(name[area + 1]  + '区域收入预测')    result['income_forecast'] = {}    result['income_forecast']['x'] = []    result['income_forecast']['y'] = []    # 先存入前五天的真实数据    time_date_1 = []    for i in range(len(mode.income_train)):        time_date_1.append(np.array(data.date).tolist()[i][5:10])        result['income_forecast']['y'].append(np.array(data.income).tolist()[i])    result['income_forecast']['x'].append(time_date_1)    time_date_2 = []    for i in range(len(pred)):        time_date_2.append(str(pred_time_index[i])[5:10])        result['income_forecast']['y'].append(pred[i])    result['income_forecast']['x'].append(time_date_2)    print(result)    flag = 0    for i in test1:        if i ==0:            flag =1            break    if flag == 0:        # # print("最终测试结果：",pred)        plt.subplot(211)        # input(mode.dataSet)        plt.plot(mode.dataSet.index, mode.dataSet.income)        # plt.plot(mode.income_train)        plt.subplot(212)        test = pd.Series(test1, index=pred_time_index, name='test')        pred.plot(color='salmon', label='Predict')        test.plot(color='steelblue', label='Original')        mode.low_conf.plot(color='grey', label='low')        mode.high_conf.plot(color='grey', label='high')        plt.legend(loc='best')        plt.tight_layout()        plt.show()    else:        # # print("最终测试结果：",pred)        plt.subplot(211)        # input(mode.dataSet)        plt.plot(mode.dataSet[:-48].index, mode.dataSet[:-48].income)        # plt.plot(mode.income_train)        plt.subplot(212)        pred.plot(color='salmon', label='Predict')        mode.low_conf.plot(color='grey', label='low')        mode.high_conf.plot(color='grey', label='high')        plt.legend(loc='best')        plt.tight_layout()        plt.show()    return resultif __name__ == '__main__':    pre_result = main_ARIMR('2017-02-20',11)    # get_MAPE(pre_result)